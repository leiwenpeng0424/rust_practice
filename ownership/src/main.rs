mod reference_borrow;
mod slice;

fn main() {
    // 所有权 ownership
    // Rust最与众不同的特征，让Rust不需要垃圾回收机制来回收内存，即可保障内存安全。

    // borrow / slice / Rust如何在内存中布局数据
    // 不管是什么语言开发的程序,只要运行在计算机中,都会需要管理其使用的内存.
    // 一些语言提供非常灵活的垃圾回收机制，在运行中不断地寻找不再使用的内存。
    // 另一些语言中，程序员需要手动地为程序分配内存空间，和释放空间。
    // Rust选择了第三种方式，通过所有权系统管理内存，
    // 编译器会在编译时根据一系列的规则进行检查，在运行时，所有权系统的任何功能都不会减慢程序的数据。

    // 了解所有权的机制，是熟悉该语言，并且编写出高效代码的前提。
    // 以下的例子，将基于一种常用的数据结构：字符串。

    // 堆，栈
    // 堆栈都是代码运行时可使用的内存空间，但是结构有些不一样。
    // 栈是按放入值的顺序存储数据，然后按相反的顺序取出数据，LIFO，后进先出。
    // 🌰： 乒乓球盒子，总是后放进去的乒乓球会被先拿出来使用。
    // 往栈中放数据成为"入栈"，取数据成为"出栈"。
    // 栈中的数据必须占用已知且固定的大小。在编译时大小会变化的数据，需要修改成存储在堆上。

    // 堆是缺乏组织的，当向堆中存放数据时，操作系统在堆的某处找到一块足够大的空间，
    // 将其标记为使用，然后返回一个内存地址指针。这个过程称为在堆上分配内存，简称为分配(allocating)
    // 🌰： 去餐厅吃饭，服务员通常会根据我们的人数，分配一个足够我们所有人坐的桌子
    // 		即使后面有人来了，也可以通过询问来找到我们坐在哪儿。

    // 入栈通常不被认为是分配，因为指针的大小是已知和固定的，你可以将指针存在栈中，
    // 但是访问实际数据的时候，还是通过指针。

    // 对栈的操作是优于堆的，栈内数据的存储是有规律的，新数据总是存放在栈顶。
    // 对堆内数据进行操作的话，需要计算机系统进行更多的额外操作。

    // 所有权的规则。
    /*
        1. Rust中的每一个值都有一个被称为其所有者(owner)的变量。
        2. 值在任一时刻有且只有一个所有者。
        3. 当所有者(变量)离开作用域，这个值将被抛弃。
    */

    // 变量作用域
    // 作用域(scope)，表示一个项在程序中的有效范围。
    let _s = "hello";
    // _s 变量将会一直持续有效，直到离开程序执行离开了当前的作用域。
    // - 当 _s 进入作用域时，它就是有效的。
    // - 有效期一直持续到它离开作用域为止

    // String
    // String类型的数据是存储在堆上的数据，之前我们讨论的数据类型都是存储在栈上的数据。

    // 前面学习了字符类型，这里看看字符串类型。
    // 通过from()基于字符串字面量创建字符。(双冒号表示运算符，从String命名空间中取函数调用)
    let mut _s = String::from("Hello World");

    _s.push_str(", from lei wenpeng");

    println!("{:?}", _s);

    // String类型的值可变，字符串字面量的值不可变。
    // 字符串字面量在编译时会硬编码进可执行文件中。
    // 对于字符串类型，为了支持可变长度的文本片段，需要将其存放在堆内存中。
    //  - 运行时请求分配内存
    //  - 提供一个方法，在处理完String类型的数据之后，释放内存的方法。

    // 第一部分由from方法来完成。
    // 第二部分的实现，不同语言不一样，对于有垃圾回收机制的语言，GC会记录并且清除不再使用的内存空间
    // 如果不存在GC的机制，回收内存就需要和分配内存一样，由开发者调用。从历史角度来看，内存的释放是
    // 非常头痛的一个问题，不能过早回收，不能过晚回收，不能重复回收，
    // 需要为每一次内存分配(allocate)准比一个释放方法(free)。

    // Rust的策略就是内存在拥有它的变量(owner)离开当前作用域就自动释放。
    // 当变量离开作用域时。Rust会自动调用drop方法来释放内存
    /*
        {

            let s = String::from("Hello World"); // s从这里开始有效。

            // 使用s。

            s.drop(); // 作用域结束，调用drop，释放内存。
        }
    */

    // 变量与数据交互
    let x = 5;
    let _y = x;
    // x和_y都是5，栈中有两个5的数据

    let x = String::from("5");
    let _y = x;
    // 代码与上面的类似，但是底层的处理完全不一样，
    // 对于 let _y  = x; 这一步，Rust底层是将 x 存储在栈中的数据复制了一份给变量 _y。
    // _y 与 x 都指向堆中的同一块内存空间。

    // 在这种情况的前提下，_y 与 x共享一块内存空间，当变量同时离开作用域时，
    // 就会有同一块内存被清空两次的操作。
    // 为了避免这种情况发生。
    // Rust会做一个极端的处理，与其尝试拷贝被分配的内存，不如直接认为被赋值的右边的对象不再有效。
    // 当 let _y = x;时，Rust认为x就不再在作用域内有效了，无效了，因此不需要在 _y 离开作用域后清理任何东西，
    // 只需要在 x 离开作用域时，清理即可。

    // 可能这看起来像是其他语言中的`浅拷贝`和`深拷贝`。
    // 拷贝指针，长度和容量，但是不拷贝世纪的内容。
    // Rust中因为会使第一个值无效，所以表现地更像是移动，而不是拷贝。
    // 按照上面的代码就是 _y 继续往下就是有效的变量，而 x 就会Rust自动抛弃，
    // 后面再使用Rust也会给出异常错误。
    // 所以，在Rust中，永远不会自动创建数据的深拷贝。

    // 克隆
    // 如果确实在应用中需要实数据的深拷贝，不仅仅复制栈上的数据，同时也复制堆上的内容。
    // 可以使用提供的clone()方法。

    let x = String::from("Hello World");
    let _y = x.clone();
    println!("x = {}, y = {}", x, _y);

    // 拷贝
    // 只在栈上的数据

    // 栈上的数据不需要调用clone方法就可以实现数据的深拷贝。
    // 所有拥有Copy traits注释的数据类型都可以实现赋值的深拷贝。
    // - 所有的整型 i32
    // - 布尔 false/true
    // - 浮点 f32
    // - 字符 char
    // - 元组，当且仅当所有的成员都是Copy类型的时候

    // 所有权与函数
    fn ownership_example() {
        let s = String::from("hello");
        take_ownership(s);

        let x = 5;

        makes_copy(5);

        println!("{:?}", x);
    }

    fn take_ownership(str: String) {
        println!("{:?}", str);
    }

    fn makes_copy(str: i32) {
        println!("{:?}", str);
    }

    ownership_example();

    // 将变量作为参数与将变量赋值给另一个变量类型，向函数传递可能会移动/复制，就像赋值语句一样。

    // 返回值与作用域
    // 函数的返回值同样可以转移所有权(ownership)
    let s1 = give_ownership();

    let s2 = String::from("hello");

    let s3 = takes_and_gives_back(s2);

    println!("{:?}", s1);
    // println!("{:?}", s2);
    println!("{:?}", s3);

    fn give_ownership() -> i32 {
        let x = 5;
        x
    };

    fn takes_and_gives_back(str: String) -> String {
        str
    }

    // 变量的所有权总是遵循相同的模式，当赋值给另一个变量时移动他。
    // 当持有堆中的数据值的变量移出作用域时，它的值将会通过drop清理掉。

    // 引用与借用
    reference_borrow::ref_code();
    let s = slice::get_slice("Hello World");
    println!("{:?}", s);
}
