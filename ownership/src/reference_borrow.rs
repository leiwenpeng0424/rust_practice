pub fn ref_code() {
    let s1 = String::from("hello");

    let length = calc_str_length(&s1);

    // 通过引用，依然保持作为参数传入的变量在函数外部的有效性。
    // 使用引用标记 & 允许你使用值而不改变变量的所有权。
    fn calc_str_length(str: &String) -> usize {
        // 接受一个对象的引用作为参数。
        str.len()
    }
    println!("{:?}", length);

    // 注意，Rust还有一个与引用相反的操作，叫做解引用使用`*`表示。
    // 我们将获取引用作为函数参数称为借用(borrowing)。引用的值默认也是immutable的。
    // 好在，Rust也支持可变的引用。
    // 但是可变引用也有一个很大的限制：在特定区域中的特定数据只能有一个可变引用。
    // 即使存在多个针对一个变量的可变引用，在使用这些变量的时候，编译器也会马上给出错误。
    let mut s = String::from("hello");
    let _s_borrow_1 = &mut s;
    let _s_borrow_2 = &mut s;

    println!("1, {:?}", _s_borrow_2);

    // 这个规则在Rust编译时可以有效地避免数据竞争。
    // - 至少有两个指针同时访问同一个数据。
    // - 至少一个指针被用来写入数据。
    // - 没有同步数据访问机制。
    // 数据竞争会导致在运行时发生未定义的行为，难以追踪。

    // 不仅仅是对于可变引用，同一有效作用域范围上同时出现了对一个变量的可变引用和不可变引用也是不行的。
    // 因为两者的表现是有冲突的, 都是引用,一个是不可修改,一个是可修改.
    // 举个🌰
    let mut s = String::from("hello");
    let s1 = &s;
    let s2 = &s;

    println!("{:?}, {:?}", s1, s2);
    // 此处 s1, s2 变量使用完之后就会失去对s的引用.
    // 这里就可以再次使用s来创建可变引用变量 s3;
    let s3 = &mut s;
    s3.push_str(" world");
    println!("{:?}", s3);
}

pub fn dangling_reference() {
    // 在具有指针的语言中,很容易出现内存被释放而指向该内存地址的指针却被保留的情况.
    // 这种无效的指针我们称之为 悬垂指针 (dangling pointer),该指针指向的内存可能已经被分配给了其他所有者.
    // 相比之下, Rust编译器确保引用永远不会变成悬垂状态:当你拥有一些数据的引用, 编译器确保数据不会在其引用之前离开作用域

    // let reference = dangle();

    // fn dangle() -> &String {
    // let s = String::from("hello");
    // &s
    // s 在程序运行到这里之后, 就被丢弃了. 如果再将结果的 &s 返回, 就会生成一个悬垂指针.
    // Rust是不会允许这种情况发生的，编译阶段就会报错。
    //
    // }
    // 引用的规则
    // - 在任意给定事件，要么只能有一个可变引用，要么只能有多个不可变引用。
    // - 引用必须总是有效的。
}
